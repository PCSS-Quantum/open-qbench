import json
import os
from abc import ABC, abstractmethod
from dataclasses import asdict, dataclass
from typing import Sequence, Union

from qiskit.primitives.containers.sampler_pub import SamplerPubLike

from .sampler.base_sampler import BaseBenchmarkSampler
from qiskit.primitives import BaseSamplerV2

class BenchmarkError(Exception):
    """Base class for errors raised by the benchmarking suite"""


@dataclass
class BenchmarkResult:
    """Dataclass for storing the results of running a fidelity benchmark"""

    name: str

    def save_to_file(self, path: str = "./results"):
        if not os.path.exists(path):
            os.makedirs(path)
        with open(
            os.path.join(path, self.name + ".json"), "w", encoding="utf-8"
        ) as file:
            file.write(json.dumps(asdict(self), indent=4))


class BaseQuantumBenchmark(ABC):
    """Abstract class defining the interface of a quantum benchmark

    A QuantumBenchmark is composed from two samplers:
        - ideal_sampler for generating ideal theoretical distributions
        - backend_sampler for sampling from a backend

    a benchmark_input is:
        for quantum circuits:
            - an input to a Qiskit Sampler in PUB-like format
        for a bosonic sampler:
            - a tuple with an input state and a sequence of parameters for bosonic samplers
        for a quantum annealer:
            - a BQM for quantum annealers
    """

    def __init__(
        self,
        backend_sampler: BaseBenchmarkSampler,
        reference_state_sampler: BaseBenchmarkSampler,
        benchmark_input: Union[
            SamplerPubLike, tuple[Sequence[int], Sequence[float]]
        ],  # maybe create a custom class for input
        name: str | None = None,
    ):
        self.benchmark_input = benchmark_input
        self.backend_sampler = backend_sampler
        self.reference_state_sampler = reference_state_sampler

        if name is not None:
            self.name = name
        else:
            if hasattr(benchmark_input, "name"):
                self.name = benchmark_input.name
        # self.result = BenchmarkResult(name=name)

    def __str__(self) -> str:
        return f"Benchmark {self.name}"

    def __repr__(self) -> str:
        return f"QuantumBenchmark({self.benchmark_input.__repr__()})"

    @property
    def backend_sampler(self):
        return self._backend_sampler

    @backend_sampler.setter
    def backend_sampler(self, sampler_instance: BaseSamplerV2):
        if not isinstance(sampler_instance, BaseSamplerV2):
            raise TypeError(
                "backend_sampler must be an instance of qiskit.primitives.BaseSamplerV2"
            )
        self._backend_sampler = sampler_instance

    @property
    def reference_state_sampler(self):
        return self._reference_state_sampler

    @reference_state_sampler.setter
    def reference_state_sampler(self, sampler_instance: BaseSamplerV2):
        if not isinstance(sampler_instance, BaseSamplerV2):
            raise TypeError(
                "ideal_sampler must be an instance of qiskit.primitives.BaseSamplerV2"
            )
        self._reference_state_sampler = sampler_instance

    @abstractmethod
    def run(self) -> BenchmarkResult:
        pass

    @abstractmethod
    def calculate_accuracy(self, state_ref: dict, dist_backend: dict):
        """This method defines how we measure the accuracy of execution of
        the quantum benchmark, e.g. fidelity between probability distributions
        [Lubinski 2021], difference in a probability of a single desired
        output state [polarization in Proctor 2022] or other

        Args:
            ref_state (dict): A reference quantum state used for benchmarking
            obtained numerically from a classical simulation or theoretically;
            can be represented by a prob. distribution or a quantum state
            dist_backend (dict): A probability dsitribution generated by a backend
        """

    @abstractmethod
    def measure_creation_time(self):
        pass
